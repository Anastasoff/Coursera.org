namespace BalancedSearchTrees
{
    using System;

    /// <summary>
    /// B-tree
    /// </summary>
    public class BTree<Key, Value> where Key : IComparable<Key>
    {
        private const int M = 4; // max children per B-tree node = M-1

        private Node root;      // root of the B-tree
        private int ht;         // height of the B-tree
        private int n;          // number of key-value pairs in the B-tree

        /// <summary>
        /// Helper B-tree node data type
        /// </summary>
        private class Node
        {
            // Create a node with k children
            internal Node(int k)
            {
                this.M = k;
                this.Children = new Entry[M];
            }

            public int M { get; set; }              // number of children

            public Entry[] Children { get; set; }   // the array of children
        }

        /// <summary>
        /// Internal nodes: only use key and next
        /// External nodes: only use key and value
        /// </summary>
        private class Entry
        {
            internal Entry(IComparable<Key> key, Value value, Node next)
            {
                this.Key = key;
                this.Value = value;
                this.Next = next;
            }

            public IComparable<Key> Key { get; set; }

            public Value Value { get; set; }

            public Node Next { get; set; } // helper field to iterate over array entries
        }

        public BTree()
        {
            this.root = new Node(0);
        }

        /// <summary>
        /// Return number of key-value pairs in the B-tree
        /// </summary>
        public int Size()
        {
            return this.n;
        }

        /// <summary>
        /// Return height of B-tree
        /// </summary>
        public int Height()
        {
            return this.ht;
        }

        /// <summary>
        /// Search for given key, return associated value; return null if no such key
        /// </summary>
        public Value Get(Key key)
        {
            return this.Search(this.root, key, this.ht);
        }

        private Value Search(Node x, Key key, int ht)
        {
            Entry[] children = x.Children;

            // external node
            if (this.ht == 0)
            {
                for (int j = 0; j < x.M; j++)
                {
                    if (true)
                    {

                    }
                }
            }

            return default(Value);
        }

        private bool Equal<T>(T k1, T k2) where T : IComparable<T>
        {
            return k1.CompareTo(k2) == 0;
        }
    }
}